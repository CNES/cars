#!/usr/bin/env python
# coding: utf8
#
# Copyright (c) 2020 Centre National d'Etudes Spatiales (CNES).
#
# This file is part of CARS
# (see https://github.com/CNES/cars).
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
Test module for cars/stereo.py
Important : Uses conftest.py for shared pytest fixtures
"""

import json
import os
import tempfile

# Third party imports
import numpy as np
import pytest
import rasterio
import xarray as xr

from cars import __version__
from cars.applications.application import Application
from cars.applications.grid_generation.transform_grid import transform_grid_func

# CARS imports
from cars.applications.resampling import resampling_algo, resampling_wrappers
from cars.conf import input_parameters as in_params
from cars.core import constants as cst
from cars.core import tiling
from cars.core.geometry.abstract_geometry import AbstractGeometry
from cars.orchestrator import orchestrator
from cars.pipelines.parameters import sensor_inputs
from cars.pipelines.parameters import sensor_inputs_constants as sens_cst
from tests.applications.grid_generation.test_grids import (
    adapt_path_for_test_dir,
)

# CARS Tests imports
from ...helpers import (
    absolute_data_path,
    assert_same_datasets,
    generate_input_json,
    get_geometry_plugin,
    temporary_dir,
)


@pytest.mark.unit_tests
def test_resample_image():
    """
    Test resample image method
    """
    region = [387, 180, 564, 340]

    imgs = {
        absolute_data_path("input/phr_ventoux/left_image.tif"): {
            "band_name": ["b0"],
            "band_id": [1],
        }
    }
    nodata = 0
    grid = {
        "path": absolute_data_path("input/stereo_input/left_epipolar_grid.tif")
    }
    epipolar_size_x = 612
    epipolar_size_y = 612

    test_dataset = resampling_algo.resample_image(
        imgs,
        grid,
        [epipolar_size_x, epipolar_size_y],
        region=region,
        nodata=nodata,
        band_coords="band_im",
    )

    # Uncomment to update baseline
    # test_dataset.to_netcdf(absolute_data_path("ref_output/data1_ref_left.nc"))

    # For convenience we use same reference as test_epipolar_rectify_images_1
    ref_dataset = xr.open_dataset(
        absolute_data_path("ref_output/data1_ref_left.nc")
    )

    # We need to remove attributes that are not generated by resample_image
    # method
    ref_dataset.attrs.pop(cst.ROI, None)
    ref_dataset.attrs.pop(cst.EPI_MARGINS, None)
    ref_dataset.attrs.pop(cst.EPI_DISP_MIN, None)
    ref_dataset.attrs.pop(cst.EPI_DISP_MAX, None)
    ref_dataset.attrs.pop(cst.ROI_WITH_MARGINS, None)
    ref_dataset.attrs.pop(cst.ROI_WITH_MARGINS, None)
    ref_dataset.attrs["band_names"] = [ref_dataset.attrs["band_names"]]

    assert_same_datasets(test_dataset, ref_dataset)


@pytest.mark.unit_tests
def test_resample_image_tiles():
    """
    Test resample image method, tile same as full cropped
    """
    region = [387, 180, 564, 340]

    img_path = absolute_data_path("input/phr_ventoux/left_image.tif")
    imgs = {}
    imgs[img_path] = {"band_name": ["b0"], "band_id": [1]}
    nodata = 0
    grid = {
        "path": absolute_data_path("input/stereo_input/left_epipolar_grid.tif")
    }
    epipolar_size_x = 612
    epipolar_size_y = 612

    full_dataset = resampling_algo.resample_image(
        imgs,
        grid,
        [epipolar_size_x, epipolar_size_y],
        nodata=nodata,
    )

    tiled_dataset = resampling_algo.resample_image(
        imgs,
        grid,
        [epipolar_size_x, epipolar_size_y],
        region=region,
        nodata=nodata,
    )

    offset = 40

    full_arr = full_dataset["im"].values[
        region[1] + offset : region[3] - offset,
        region[0] + offset : region[2] - offset,
    ]
    tiled_arr = tiled_dataset["im"].values[offset:-offset, offset:-offset]

    np.testing.assert_equal(full_arr, tiled_arr)


@pytest.mark.unit_tests
def test_epipolar_rectify_images_1(
    images_and_grids_conf,
    color1_conf,  # pylint: disable=redefined-outer-name
    epipolar_sizes_conf,  # pylint: disable=redefined-outer-name
    epipolar_origins_spacings_conf,  # pylint: disable=redefined-outer-name
    no_data_conf,
):  # pylint: disable=redefined-outer-name
    """
    Test epipolar_rectify_image on ventoux dataset (epipolar geometry)
    with nodata and color
    """
    configuration = images_and_grids_conf
    configuration["input"].update(color1_conf["input"])
    configuration["input"].update(no_data_conf["input"])
    configuration["preprocessing"]["output"].update(
        epipolar_sizes_conf["preprocessing"]["output"]
    )
    configuration["preprocessing"]["output"].update(
        epipolar_origins_spacings_conf["preprocessing"]["output"]
    )

    region = [420, 200, 530, 320]
    col = np.arange(4)
    margin = xr.Dataset(
        {"left_margin": (["col"], np.array([33, 20, 34, 20]))},
        coords={"col": col},
    )
    margin["right_margin"] = xr.DataArray(
        np.array([33, 20, 34, 20]), dims=["col"]
    )

    margin.attrs[cst.EPI_DISP_MIN] = -13
    margin.attrs[cst.EPI_DISP_MAX] = 14

    # Rectify images
    # retrieves some data
    epipolar_size_x = configuration["preprocessing"]["output"][
        "epipolar_size_x"
    ]
    epipolar_size_y = configuration["preprocessing"]["output"][
        "epipolar_size_y"
    ]
    img1 = configuration["input"][in_params.IMG1_TAG]
    left_imgs = {img1: {"band_name": ["b0"], "band_id": [1]}}
    img2 = configuration["input"][in_params.IMG2_TAG]
    right_imgs = {img2: {"band_name": ["b0"], "band_id": [1]}}
    grid1 = {
        "path": configuration["preprocessing"]["output"]["left_epipolar_grid"]
    }
    grid2 = {
        "path": configuration["preprocessing"]["output"]["right_epipolar_grid"]
    }
    nodata1 = configuration["input"].get(in_params.NODATA1_TAG, None)
    nodata2 = configuration["input"].get(in_params.NODATA2_TAG, None)
    mask1 = configuration["input"].get(in_params.MASK1_TAG, None)
    mask2 = configuration["input"].get(in_params.MASK2_TAG, None)
    classif1 = configuration["input"].get(in_params.CLASSIFICATION1_TAG, None)
    left_classifs = None
    if classif1 is not None:
        left_classifs = {img1: {"band_name": ["b0"], "band_id": [1]}}
    classif2 = configuration["input"].get(in_params.CLASSIFICATION2_TAG, None)
    right_classifs = None
    if classif2 is not None:
        right_classifs = {img1: {"band_name": ["b0"], "band_id": [1]}}

    (
        left,
        right,
        classif1,
        classif2,
    ) = resampling_algo.epipolar_rectify_images(
        left_imgs,
        right_imgs,
        grid1,
        grid2,
        region,
        margin,
        epipolar_size_x,
        epipolar_size_y,
        mask1=mask1,
        mask2=mask2,
        left_classifs=left_classifs,
        right_classifs=right_classifs,
        nodata1=nodata1,
        nodata2=nodata2,
    )

    # Uncomment to update baseline
    # left.to_netcdf(absolute_data_path("ref_output_application/resampling"
    # "/data1_ref_left.nc"))

    left_ref = xr.open_dataset(
        absolute_data_path(
            "ref_output_application/resampling/data1_ref_left.nc"
        )
    )

    # Brackets are lost in dataset reading
    left_ref.attrs["band_names"] = [left_ref.attrs["band_names"]]
    left_ref.attrs["image_type"] = [left_ref.attrs["image_type"]]
    assert_same_datasets(left, left_ref)

    # Uncomment to update baseline
    # right.to_netcdf(absolute_data_path("ref_output_application/resampling"
    # "/data1_ref_right.nc"))

    right_ref = xr.open_dataset(
        absolute_data_path(
            "ref_output_application/resampling/data1_ref_right.nc"
        )
    )
    right_ref.attrs["band_names"] = [right_ref.attrs["band_names"]]
    right_ref.attrs["image_type"] = [right_ref.attrs["image_type"]]
    assert_same_datasets(right, right_ref)


@pytest.mark.unit_tests
def test_epipolar_rectify_images_3(
    images_and_grids_conf,  # pylint: disable=redefined-outer-name
    color_pxs_conf,  # pylint: disable=redefined-outer-name
    epipolar_sizes_conf,  # pylint: disable=redefined-outer-name
    epipolar_origins_spacings_conf,  # pylint: disable=redefined-outer-name
    no_data_conf,
):  # pylint: disable=redefined-outer-name
    """
    Test epipolar_rectify_image on ventoux dataset (epipolar geometry)
    with nodata and color as a p+xs fusion
    """
    configuration = images_and_grids_conf
    configuration["input"].update(color_pxs_conf["input"])
    configuration["input"].update(no_data_conf["input"])
    configuration["preprocessing"]["output"].update(
        epipolar_sizes_conf["preprocessing"]["output"]
    )
    configuration["preprocessing"]["output"].update(
        epipolar_origins_spacings_conf["preprocessing"]["output"]
    )

    region = [420, 200, 530, 320]
    col = np.arange(4)
    margin = xr.Dataset(
        {"left_margin": (["col"], np.array([33, 20, 34, 20]))},
        coords={"col": col},
    )
    margin["right_margin"] = xr.DataArray(
        np.array([33, 20, 34, 20]), dims=["col"]
    )

    margin.attrs[cst.EPI_DISP_MIN] = -13
    margin.attrs[cst.EPI_DISP_MAX] = 14

    # Rectify images
    # retrieves some data
    epipolar_size_x = configuration["preprocessing"]["output"][
        "epipolar_size_x"
    ]
    epipolar_size_y = configuration["preprocessing"]["output"][
        "epipolar_size_y"
    ]
    img1 = configuration["input"][in_params.IMG1_TAG]
    left_imgs = {img1: {"band_name": ["b0"], "band_id": [1]}}
    img2 = configuration["input"][in_params.IMG2_TAG]
    right_imgs = {img2: {"band_name": ["b0"], "band_id": [1]}}
    grid1 = {
        "path": configuration["preprocessing"]["output"]["left_epipolar_grid"]
    }
    grid2 = {
        "path": configuration["preprocessing"]["output"]["right_epipolar_grid"]
    }
    nodata1 = configuration["input"].get(in_params.NODATA1_TAG, None)
    nodata2 = configuration["input"].get(in_params.NODATA2_TAG, None)
    mask1 = configuration["input"].get(in_params.MASK1_TAG, None)
    mask2 = configuration["input"].get(in_params.MASK2_TAG, None)
    classif1 = configuration["input"].get(in_params.CLASSIFICATION1_TAG, None)
    left_classifs = None
    if classif1 is not None:
        left_classifs = {img1: {"band_name": ["b0"], "band_id": [1]}}
    classif2 = configuration["input"].get(in_params.CLASSIFICATION2_TAG, None)
    right_classifs = None
    if classif2 is not None:
        right_classifs = {img1: {"band_name": ["b0"], "band_id": [1]}}
    (
        left,
        right,
        class1,
        class2,
    ) = resampling_algo.epipolar_rectify_images(
        left_imgs,
        right_imgs,
        grid1,
        grid2,
        region,
        margin,
        epipolar_size_x,
        epipolar_size_y,
        mask1=mask1,
        mask2=mask2,
        left_classifs=left_classifs,
        right_classifs=right_classifs,
        nodata1=nodata1,
        nodata2=nodata2,
    )

    left_ref = xr.open_dataset(
        absolute_data_path(
            "ref_output_application/resampling/data1_ref_left.nc"
        )
    )
    # Brackets are lost in dataset reading
    left_ref.attrs["band_names"] = [left_ref.attrs["band_names"]]
    left_ref.attrs["image_type"] = [left_ref.attrs["image_type"]]
    assert_same_datasets(left, left_ref)

    right_ref = xr.open_dataset(
        absolute_data_path(
            "ref_output_application/resampling/data1_ref_right.nc"
        )
    )
    right_ref.attrs["band_names"] = [right_ref.attrs["band_names"]]
    right_ref.attrs["image_type"] = [right_ref.attrs["image_type"]]
    assert_same_datasets(right, right_ref)

    assert class1 is None
    assert class2 is None


def test_resampling_low_res():  # pylint: disable=redefined-outer-name):
    """
    Test the low res resampling
    """
    input_file = "grid_generation_gizeh_ROI_no_color.json"

    with tempfile.TemporaryDirectory(dir=temporary_dir()) as directory:
        conf = {}
        conf["out_dir"] = directory
        input_relative_path = os.path.join("input", "test_application")
        input_path = absolute_data_path(input_relative_path)
        # Triangulation
        epipolar_grid_generation_application = Application(
            "grid_generation", cfg=conf.get("grid_generation", {})
        )
        orchestrator_conf = {
            "mode": "sequential",
            "max_ram_per_worker": 40,
            "profiling": {"mode": "cars_profiling"},
        }

        with orchestrator.Orchestrator(
            orchestrator_conf=orchestrator_conf
        ) as cars_orchestrator:
            # initialize out_json
            cars_orchestrator.update_out_info({"version": __version__})
            # load dictionary of cardatasets
            with open(
                absolute_data_path(
                    os.path.join(input_relative_path, input_file)
                ),
                "rb",
            ) as file:
                # load pickle data
                data = json.load(file)
                adapt_path_for_test_dir(data, input_path)
                # Run grid generation
                geometry_plugin = get_geometry_plugin(
                    dem=os.path.join(
                        input_path, "srtm_dir", "N29E031_KHEOPS.tif"
                    ),
                    default_alt=0,
                )
                (
                    grid_left,
                    grid_right,
                ) = epipolar_grid_generation_application.run(
                    data["sensor_image_left"],
                    data["sensor_image_right"],
                    geometry_plugin,
                    orchestrator=cars_orchestrator,
                    pair_folder=os.path.join(directory, "pair_0"),
                )

                res = 4

                grid_left = transform_grid_func(
                    grid_left,
                    grid_right,
                    res,
                )

                resampling_application = Application("resampling", {})

                (
                    img1,
                    img2,
                ) = resampling_application.run(
                    data["sensor_image_left"],
                    data["sensor_image_right"],
                    grid_left,
                    grid_right,
                    geometry_plugin,
                    orchestrator=cars_orchestrator,
                    pair_folder=os.path.join(directory, "pair_0"),
                    add_color=False,
                    resolution=res,
                )

                with rasterio.open(data["sensor_image_left"]["image"]) as src:
                    data1 = src.read(1)

                with rasterio.open(data["sensor_image_right"]["image"]) as src:
                    data2 = src.read(1)

                size1 = img1[0, 0].sizes
                size2 = img2[0, 0].sizes

                assert np.allclose(
                    (size1["row"], size1["col"]),
                    (data1.shape[0] / res, data1.shape[1] / res),
                    0.05,
                )
                assert np.allclose(
                    (size2["row"], size2["col"]),
                    (data2.shape[0] / res, data2.shape[1] / res),
                    0.05,
                )


@pytest.mark.unit_tests
def test_check_tiles_in_sensor():
    """
    Test tile dumping
    """

    with tempfile.TemporaryDirectory(dir=temporary_dir()) as directory:
        input_json = absolute_data_path("input/phr_ventoux/input.json")

        _, input_data = generate_input_json(
            input_json,
            directory,
            "local_dask",
            orchestrator_parameters={
                "walltime": "00:10:00",
                "nb_workers": 4,
                "max_ram_per_worker": 1000,
            },
        )

        inputs = input_data["inputs"]
        list_sensor_pairs = sensor_inputs.generate_inputs(
            inputs, get_geometry_plugin()
        )

        sensor_image_left = list_sensor_pairs[0][1]

        sensor_image_right = list_sensor_pairs[0][2]

        # Generate grids
        geometry_plugin = get_geometry_plugin(
            dem=inputs[sens_cst.INITIAL_ELEVATION][sens_cst.DEM_PATH],
            default_alt=sens_cst.CARS_DEFAULT_ALT,
        )

        with orchestrator.Orchestrator(
            orchestrator_conf={"mode": "sequential"}
        ) as cars_orchestrator:
            epipolar_grid_generation_application = Application(
                "grid_generation"
            )
            (
                grid_left,
                grid_right,
            ) = epipolar_grid_generation_application.run(
                sensor_image_left,
                sensor_image_right,
                geometry_plugin,
                orchestrator=cars_orchestrator,
                pair_folder=directory,
                pair_key="one_two",
            )

            opt_epipolar_tile_size = 10

            # generate epipolar image tiling grid
            epi_tilling_grid = tiling.generate_tiling_grid(
                0,
                0,
                grid_left["epipolar_size_y"],
                grid_left["epipolar_size_x"],
                opt_epipolar_tile_size,
                opt_epipolar_tile_size,
            )

            geom_plugin = AbstractGeometry(  # pylint: disable=E0110
                "SharelocGeometry"
            )

            # Check if tiles are in sensors
            (
                in_sensor_left_array,
                in_sensor_right_array,
            ) = resampling_wrappers.check_tiles_in_sensor(
                sensor_image_left,
                sensor_image_right,
                epi_tilling_grid,
                grid_left,
                grid_right,
                geom_plugin,
            )

            # Assert number of tiles used

            # 3059 tiles used on 3844
            assert np.sum(in_sensor_left_array) == 3059
            # 1426 tiles used on 3844
            assert np.sum(in_sensor_right_array) == 1426
